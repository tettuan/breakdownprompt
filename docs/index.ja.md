# ライブラリ概要

渡された引数やオプションから、読み込むプロンプトを読み込む。
読み込んだプロンプト内の変数（ルール化された文字列）を、受け取ったパラメータ値で置き換える。
出力は標準出力へ書き出される。

# 受け取りパラメータ一覧

- prompt_file_path : プロンプトファイルのパス （必須）
- variables : プロンプト内で置換される変数の key value セット （必須）
  - 「置換処理の対象変数」で詳細を定義している

# プロンプトファイルの取り扱い

プロンプトファイルのパスは引数として直接受け取る。ライブラリ内でパスの組み立ては行わない。

## 宣言とパラメータ

初期化時に prompt_file_path が指定される。

# プロンプトの読み込みと、パラメータ値の置換

## 出力形式

すべての出力において、プロンプトの内容を表示します。 表示時に「置換処理」を行ったうえで出力します。

ex.： 入力プロンプトの内容： ```prompt

# example prompt

this is a propmt contents. {input_markdown_file} {input_markdown}

# schema

{schema_file}

# destination path

{destination_path}

````
出力： ```
# example prompt 
this is a propmt contents.
./.agent/breakdown/issues/12345_something.md
# input markdown
this is a input markdown contents.

# schema
./rules/schema/task/base.schema.json

# destination path
./.agent/breakdown/tasks/
````

## 置換処理

置換処理は、1つの変数名に1つのクラスを割り当てる。 クラスは、置き換える処理のルールを定義している。

流れとしては、

1. プロンプトファイルをスキャンし、変数が見つかったらクラスを宣言する。
2. クラスが必要とするパラメータをインスタンスへ渡す。どのような値を生成するか各クラスへ委譲する。
3. 各クラスは生成後の値を返す。 3-1. 最もシンプルな「値をそのまま返す」だけの親クラスを作成する 3-2.
   各変数クラスは 3-1 の親クラスを継承する

### 置換処理の対象変数

`./type_of_variables.ja.md` に詳細を定義している。

受け取りパラメータ variables が許可している変数は次のとおり。 variables.schema_file
でアクセス可能とする。

- schema_file
- input_markdown
- input_markdown_file
- destination_path

- 各変数の値の制約
  - `schema_file`: 有効なファイルパス形式
  - `input_markdown`: マークダウン形式のテキスト
  - `input_markdown_file`: 有効なファイルパス形式
  - `destination_path`: 有効なディレクトリパス形式

- 検出方法
  - 単純な文字列マッチングで `{variable_name}` パターンを検出
  - 正規表現は使用しない

- 値の検証ルール
  - パスの存在確認
  - ファイルの読み取り権限確認
  - マークダウンの形式チェック
  - パスの正規化処理

#### キーの制約ルール

1. キーの命名規則
   - 英数字とアンダースコアのみ使用可能
   - 先頭は英字のみ
   - 大文字小文字を使って構成されていれば命名ルールは問わない

2. キーの一意性
   - 重複するキーは許可しない
   - 大文字小文字を区別する

3. キーの必須性
   - すべてのキーは任意
   - 必須なキーは存在しない

4. キーの検証タイミング
   - 初期化時に一括検証

5. エラー処理
   - 不正なキー検出時はデバッグログに出力
   - 実行は継続（エラーは発生させない）
   - 不正なキーは無視して処理を継続

- 同じ変数が複数回出現した場合は、全て同じ値で置き換える
- 変数の置換順序はシステムの呼び出し順で良い（順不同）
- 再起的な処理は不要
- 変数のエスケープ記載を検知する必要はない（検出しない）

# エラーハンドリング

- 置換対象の変数はあらかじめ指定されている
  - 指定以外の変数が見つかった場合は、 log debug レベルで出力する
  - 例外は発生させずスルーする

# テスト

- コア機能の単体テストから統合機能、最終的なユースケースのカバレッジ拡大へと階層的なテストにする
- BreakdownLoggerをテストコードへ入れてデバッグする

## セキュリティ考慮

ローカルファイル操作に対して最小限行う。

- パスインジェクション対策
- 特殊文字の処理
- ファイルアクセス権限の確認
- 機密情報の扱いは不要（ログはコンソールへ出力するのみ）

## パフォーマンス考慮

不要。もともと軽量な処理であるため。
