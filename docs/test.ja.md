# テスト

## デバッグモード

### local_ci.sh のデバッグモード

`local_ci.sh` スクリプトでは、以下の方法でデバッグモードを制御できます：

1. 通常実行（デバッグモードなし）:

```bash
./scripts/local_ci.sh
```

2. デバッグモードで実行:

```bash
DEBUG=true ./scripts/local_ci.sh
```

デバッグモードの動作：

- デフォルトではデバッグモードは無効
- `DEBUG=true` を指定すると、スクリプト開始時からデバッグモードが有効
- 以下のエラー時に自動的にデバッグモードが有効になります：
  - deno.lock の再生成失敗
  - テストの失敗
  - フォーマットチェックの失敗
  - リントチェックの失敗

# テスト階層構造

```
tests/
├── 01_unit/                    # 単体テスト
│   ├── 01_core/               # コアコンポーネントのテスト
│   │   ├── 01_prompt_manager_test.ts      # プロンプト管理の基本機能
│   │   ├── 02_prompt_reader_test.ts       # プロンプトファイル読み込み
│   │   └── 03_variable_replacer_test.ts   # 変数置換処理
│   ├── 02_validation/         # バリデーション関連のテスト
│   │   ├── 01_path_validator_test.ts      # パス検証
│   │   ├── 02_variable_validator_test.ts  # 変数名検証
│   │   └── 03_parameter_validator_test.ts # パラメータ検証
│   └── 03_utils/             # ユーティリティのテスト
│       ├── 01_logger_test.ts              # ログ出力
│       └── 02_file_utils_test.ts          # ファイル操作
│
├── 02_integration/            # 統合テスト
│   ├── 01_prompt_processing_test.ts       # プロンプト処理フロー
│   ├── 02_variable_chain_test.ts          # 変数連鎖処理
│   └── 03_parameter_flow_test.ts          # パラメータ処理フロー
│
├── 03_system/                # システムテスト
│   ├── 01_end_to_end_test.ts              # エンドツーエンド
│   └── 02_error_handling_test.ts          # エラー処理
│
└── 00_fixtures/              # テスト用データ
    ├── 01_prompts/           # プロンプトファイル
    │   ├── 01_basic.md
    │   ├── 02_with_variables.md
    │   └── 03_invalid/
    ├── 02_variables/         # 変数データ
    │   ├── 01_valid.json
    │   └── 02_invalid.json
    └── 03_expected/          # 期待出力
        ├── 01_basic_output.md
        └── 02_variable_output.md
```

## テスト実行順序の説明

### 1. フィクスチャの準備 (00_fixtures/)

テストデータの準備は最初に行う必要があります。これにより、後続のテストで必要なデータが確実に利用可能になります。

### 2. 単体テスト (01_unit/)

#### 2.1 コアコンポーネント (01_core/)
1. `01_prompt_manager_test.ts`: プロンプト管理の基本機能
   - 最も基本的な機能からテストを開始
   - 他のコンポーネントの基盤となる機能

2. `02_prompt_reader_test.ts`: プロンプトファイル読み込み
   - ファイル操作の基本機能
   - プロンプト管理に必要な機能

3. `03_variable_replacer_test.ts`: 変数置換処理
   - コア機能の最後の要素
   - 他の機能に依存する部分

#### 2.2 バリデーション (02_validation/)
1. `01_path_validator_test.ts`: パス検証
   - ファイル操作の前提となる検証
   - セキュリティの基本

2. `02_variable_validator_test.ts`: 変数名検証
   - 変数処理の前提となる検証
   - 命名規則の確認

3. `03_parameter_validator_test.ts`: パラメータ検証
   - 入力値の検証
   - 型チェックの確認

#### 2.3 ユーティリティ (03_utils/)
1. `01_logger_test.ts`: ログ出力
   - デバッグの基本機能
   - エラー追跡の基盤

2. `02_file_utils_test.ts`: ファイル操作
   - ファイル操作のユーティリティ
   - 共通機能の確認

### 3. 統合テスト (02_integration/)

1. `01_prompt_processing_test.ts`: プロンプト処理フロー
   - 基本的な統合テスト
   - コア機能の連携確認

2. `02_variable_chain_test.ts`: 変数連鎖処理
   - 変数処理の統合
   - 複雑な処理の確認

3. `03_parameter_flow_test.ts`: パラメータ処理フロー
   - パラメータ処理の統合
   - 入力値の流れの確認

### 4. システムテスト (03_system/)

1. `01_end_to_end_test.ts`: エンドツーエンド
   - 完全なユースケースのテスト
   - システム全体の動作確認

2. `02_error_handling_test.ts`: エラー処理
   - エラーケースの確認
   - システムの堅牢性の確認

## テスト階層の説明

### 1. 単体テスト (unit/)

- コアコンポーネント (core/)
  - PromptManager: プロンプト管理の基本機能
    - プロンプトファイルの特定と読み込み
    - パラメータの検証と管理
    - プロンプト生成プロセスの調整
  - PromptReader: プロンプトファイルの読み込み処理
    - ファイルの存在確認
    - 読み取り権限の確認
    - ファイル内容の読み込み
  - VariableReplacer: 変数置換処理の実装
    - 変数の検出と置換
    - 置換値の生成
    - エラー処理

- バリデーション (validation/)
  - PathValidator: パス検証ルールの実装
    - 空パスの検証
    - 文字セットの検証
    - パストラバーサルの防止
    - 絶対パスの制限
  - VariableValidator: 変数名の命名規則検証
    - 英数字とアンダースコアの検証
    - 先頭文字の検証
    - 大文字小文字の区別
  - ParameterValidator: パラメータ値の検証
    - ファイルパスの検証
    - マークダウンの検証
    - ディレクトリパスの検証

- ユーティリティ (utils/)
  - Logger: デバッグログ出力
    - ログレベルの制御
    - デバッグ情報の出力
    - エラーログの出力
  - FileUtils: ファイル操作関連
    - ファイルの読み書き
    - パスの正規化
    - 権限の確認

### 2. 統合テスト (integration/)

- プロンプト処理フロー
  - ファイル読み込みから変数置換までの一連の流れ
    - プロンプトファイルの読み込み
    - 変数の検出と置換
    - 出力の生成
  - エラー処理の連携
    - バリデーションエラーの処理
    - ファイル操作エラーの処理
    - デバッグログの出力

- 変数連鎖処理
  - 複数変数の置換処理
    - 変数の検出順序
    - 置換値の生成
    - 出力の整合性
  - 変数間の依存関係
    - 変数の参照関係
    - 循環参照の防止
    - エラー処理

- パラメータ処理フロー
  - パラメータの検証から値の設定まで
    - パラメータのバリデーション
    - 値の型チェック
    - エラー処理

### 3. システムテスト (system/)

- エンドツーエンドテスト
  - 実際のユースケースに基づくテスト
    - プロンプトの生成
    - 変数の置換
    - 出力の検証
  - 入力から出力までの完全なフロー
    - パラメータの受け渡し
    - 処理の実行
    - 結果の検証

- エラー処理テスト
  - 各種エラーケースの検証
    - バリデーションエラー
    - ファイル操作エラー
    - パラメータエラー
  - エラーメッセージの確認
    - メッセージの内容
    - ログレベルの適切性
    - エラー処理の継続性

### 4. テストフィクスチャ (fixtures/)

- プロンプトファイル
  - 基本的なプロンプト
    - シンプルなテキスト
    - 変数を含まない
  - 変数を含むプロンプト
    - 単一の変数
    - 複数の変数
    - 特殊文字を含む
  - 無効なプロンプト
    - 不正な変数名
    - 不正な構文
    - 特殊文字の誤用

- 変数データ
  - 有効な変数セット
    - 正しい変数名
    - 正しい値の型
    - 正しいパス形式
  - 無効な変数セット
    - 不正な変数名
    - 不正な値の型
    - 不正なパス形式

- 期待出力
  - 基本的な出力例
    - 変数置換なし
    - シンプルな形式
  - 変数置換後の出力例
    - 単一変数の置換
    - 複数変数の置換
    - 特殊文字の処理

# エラーメッセージ

- アプリケーションのテストメッセージをENUM定義する
- テストのエラーメッセージ検証は、同じ結果を期待する場合、同じENUMメッセージを利用する
  - エラーメッセージが異なることを確認する場合は、テストに異なるメッセージを記載する

## デバッグ出力

### テストコードでの使用

```typescript
import { BreakdownLogger } from "@tettuan/breakdownlogger";

const logger = new BreakdownLogger();
logger.debug("テスト実行開始", { testName: "example" });
```

### ログレベル

- `debug`: 詳細なデバッグ情報
- `info`: 重要な処理の開始/終了
- `warn`: 警告（回復可能なエラー）
- `error`: エラー（処理中断）

## エラー処理とデバッグ

### エラー発生時の調査手順

1. デバッグログの確認
2. テスト環境の状態確認
3. 関連するテストケースの実行
4. エラー再現手順の文書化

### テスト失敗時の対応

1. エラーメッセージの確認
2. デバッグモードでの再実行
3. 関連する実装の確認
4. テスト失敗の前処理判定
5. 修正と再テスト

### テスト失敗の前処理判定

- テストの目的ではない前処理で失敗した場合、別の処理前のテストが必要。
- 前処理のテストは local_ci.sh で先に実行済みとなるように、実行順を前段階で配置する。
- 前処理の例：
  - 設定判定のテストだが設定ファイルの読み込みに失敗する
    - 設定ファイルの読み込みテストを作る
- 前処理ではない例:
  - 設定判定のテストで設定値が一致しないため失敗する
- テストの前処理は、該当テストより前に実施された確認済みプロセスを利用すること。後工程のテストが独自実装しないことが重要。

# スケルトンコードの構築順序(テスト駆動)

- 「テストディレクトリ構造」に従い、テストファイルを作成する
- スケルトンの作成：テスト項目を、先にテスト対象として記述する（まだテストの内容は書かない）
- スケルトンには、テストが失敗する記述を入れておく
- コメントを記載する
  - あなたが他人のコードを読んだときに「知りたい」と思うことを記載する
  - テストの意図や目的、テストした方が良いと考えた理由を記述する
  - テストが扱う対象を明記する
