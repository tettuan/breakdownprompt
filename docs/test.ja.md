# テスト

## デバッグモード

### local_ci.sh のデバッグモード

`local_ci.sh` スクリプトでは、以下の方法でデバッグモードを制御できます：

1. 通常実行（デバッグモードなし）:

```bash
./scripts/local_ci.sh
```

2. デバッグモードで実行:

```bash
DEBUG=true ./scripts/local_ci.sh
```

デバッグモードの動作：

- デフォルトではデバッグモードは無効
- `DEBUG=true` を指定すると、スクリプト開始時からデバッグモードが有効
- 以下のエラー時に自動的にデバッグモードが有効になります：
  - deno.lock の再生成失敗
  - テストの失敗
  - フォーマットチェックの失敗
  - リントチェックの失敗

# テスト階層構造

```
tests/
├── unit/                    # 単体テスト
│   ├── core/               # コアコンポーネントのテスト
│   │   ├── prompt_manager_test.ts
│   │   ├── prompt_generator_test.ts
│   │   └── variable_replacer_test.ts
│   ├── validation/         # バリデーション関連のテスト
│   │   ├── path_validator_test.ts
│   │   ├── markdown_validator_test.ts
│   │   └── schema_validator_test.ts
│   └── utils/             # ユーティリティのテスト
│       ├── logger_test.ts
│       └── file_utils_test.ts
│
├── integration/            # 統合テスト
│   ├── prompt_flow_test.ts    # プロンプト処理フロー
│   ├── variable_chain_test.ts # 変数連鎖処理
│   └── template_link_test.ts  # テンプレート連携
│
├── system/                # システムテスト
│   ├── end_to_end_test.ts    # エンドツーエンド
│   └── error_handling_test.ts # エラー処理
│
├── security/              # セキュリティテスト
│   ├── path_injection_test.ts # パスインジェクション
│   └── input_validation_test.ts # 入力検証
│
└── fixtures/              # テスト用データ
    ├── input/            # 入力データ
    │   ├── basic.md
    │   ├── structured.md
    │   └── invalid/
    ├── output/           # 期待出力
    │   ├── basic_expected.md
    │   └── structured_expected.md
    ├── schema/           # スキーマ定義
    │   └── test_schema.json
    └── templates/        # テンプレート
        ├── basic.md
        └── structured.md
```

## テスト階層の説明

### 1. 単体テスト (unit/)

- 各コンポーネントの独立した機能テスト
- インターフェースの実装確認
- エッジケースの検証

### 2. 統合テスト (integration/)

- コンポーネント間の連携テスト
- データフローの検証
- エラー伝播の確認

### 3. システムテスト (system/)

- エンドツーエンドのユースケーステスト
- 実際の運用シナリオの検証

### 4. セキュリティテスト (security/)

- パスインジェクション対策
- 入力検証

### 5. テストフィクスチャ (fixtures/)

- テストデータの管理
- 入力/出力のサンプル
- スキーマ定義
- テンプレート例

# エラーメッセージ

- アプリケーションのテストメッセージをENUM定義する
- テストのエラーメッセージ検証は、同じ結果を期待する場合、同じENUMメッセージを利用する
  - エラーメッセージが異なることを確認する場合は、テストに異なるメッセージを記載する

## デバッグ出力

### テストコードでの使用

```typescript
import { BreakdownLogger } from "@tettuan/breakdownlogger";

const logger = new BreakdownLogger();
logger.debug("テスト実行開始", { testName: "example" });
```

### ログレベル

- `debug`: 詳細なデバッグ情報
- `info`: 重要な処理の開始/終了
- `warn`: 警告（回復可能なエラー）
- `error`: エラー（処理中断）

## エラー処理とデバッグ

### エラー発生時の調査手順

1. デバッグログの確認
2. テスト環境の状態確認
3. 関連するテストケースの実行
4. エラー再現手順の文書化

### テスト失敗時の対応

1. エラーメッセージの確認
2. デバッグモードでの再実行
3. 関連する実装の確認
4. テスト失敗の前処理判定
5. 修正と再テスト

### テスト失敗の前処理判定

- テストの目的ではない前処理で失敗した場合、別の処理前のテストが必要。
- 前処理のテストは local_ci.sh で先に実行済みとなるように、実行順を前段階で配置する。
- 前処理の例：
  - 設定判定のテストだが設定ファイルの読み込みに失敗する
    - 設定ファイルの読み込みテストを作る
- 前処理ではない例:
  - 設定判定のテストで設定値が一致しないため失敗する
- テストの前処理は、該当テストより前に実施された確認済みプロセスを利用すること。後工程のテストが独自実装しないことが重要。

# スケルトンコードの構築順序(テスト駆動)

- 「テストディレクトリ構造」に従い、テストファイルを作成する
- スケルトンの作成：テスト項目を、先にテスト対象として記述する（まだテストの内容は書かない）
- スケルトンには、テストが失敗する記述を入れておく
- コメントを記載する
  - あなたが他人のコードを読んだときに「知りたい」と思うことを記載する
  - テストの意図や目的、テストした方が良いと考えた理由を記述する
  - テストが扱う対象を明記する
